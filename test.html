<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Network Graph Background</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
      }
      #graph {
        width: 100vw;
        height: 100vh;
        position: fixed;
        top: 0;
        left: 0;
        z-index: -1;
      }
      #node-label {
        position: absolute;
        display: none;
        color: white;
        background: rgba(0, 0, 0, 0.7);
        padding: 5px;
        border-radius: 3px;
        font-family: "Arial", sans-serif;
        transform: translateX(-50%);
      }
    </style>
  </head>
  <body>
    <div id="graph"></div>
    <div id="node-label"></div>
    <script src="//cdn.jsdelivr.net/npm/three"></script>
    <script src="//cdn.jsdelivr.net/npm/3d-force-graph"></script>
    <script>
      // Placeholder texture (replace 'pr.png' with your image URL or use a data URL)
      const prTexture = new THREE.TextureLoader().load(
        "https://via.placeholder.com/50?text=PR"
      );

      // Generate graph data
      const N = 100;
      const prCount = 70;
      const dotCount = 30;
      const nodes = [];
      for (let i = 1; i <= prCount; i++) {
        nodes.push({
          id: `PR${i}`,
          name: `PR${i}`,
          type: "PR",
          val: 5 + Math.random() * 5, // Sizes between 5 and 10
        });
      }
      for (let i = 1; i <= dotCount; i++) {
        nodes.push({
          id: `dot${i}`,
          type: "dot",
          val: 1, // Fixed size for dots
        });
      }

      // Generate random links
      const links = [];
      for (let i = 0; i < N; i++) {
        for (let j = i + 1; j < N; j++) {
          if (Math.random() < 0.05) {
            links.push({ source: nodes[i].id, target: nodes[j].id });
          }
        }
      }

      // Initialize the 3D Force Graph
      const Graph = ForceGraph3D()(document.getElementById("graph"))
        .graphData({ nodes, links })
        .nodeThreeObject((node) => {
          if (node.type === "PR") {
            const sprite = new THREE.Sprite(
              new THREE.SpriteMaterial({ map: prTexture })
            );
            sprite.scale.set(node.val, node.val, 1);
            return sprite;
          }
          return null; // Default sphere for dots
        })
        .linkDirectionalParticles(3)
        .linkDirectionalParticleSpeed(0.01)
        .linkDirectionalParticleWidth(1)
        .linkColor("rgba(255,255,255,0.2)")
        .nodeColor((node) => (node.type === "dot" ? "white" : null))
        .backgroundColor("#000011")
        .enableNavigationControls(false);

      // Hover effects
      let hoveredNode = null;
      Graph.onNodeHover((node, prevNode) => {
        if (prevNode && prevNode.type === "PR") {
          prevNode.__threeObj.scale.set(prevNode.val, prevNode.val, 1);
        }
        if (node && node.type === "PR") {
          node.__threeObj.scale.set(node.val * 1.2, node.val * 1.2, 1);
          hoveredNode = node;
          const label = document.getElementById("node-label");
          label.textContent = node.name;
          label.style.display = "block";
          updateLabelPosition();
        } else {
          hoveredNode = null;
          document.getElementById("node-label").style.display = "none";
        }
      });

      function updateLabelPosition() {
        if (hoveredNode) {
          const { x, y } = Graph.graph2ScreenCoords(
            hoveredNode.x,
            hoveredNode.y,
            hoveredNode.z
          );
          const label = document.getElementById("node-label");
          label.style.left = `${x}px`;
          label.style.top = `${y + 20}px`;
          requestAnimationFrame(updateLabelPosition);
        }
      }
    </script>
  </body>
</html>
